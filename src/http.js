

/**Http是什么：超文本传输协议
 * 1. 协议：HTTP是一个用在计算机世界里的协议
 *    他使用计算机能够理解的语言确立了一种计算机之间交流
 *    通信的规范，以及相关的各种控制和错误处理方式
 * 
 * 2. 传输：是一个双向协议
 *    HTTP是一个在计算机世界里专门用来在两点之间传输数据的约定和规范
 * 
 * 3. 超文本：HTTP是一个在计算机世界里专门在两点之间传输文字、
 *    图片、音频、视频等超文本数据的约定和规范
 * 
 * 4. HTTP不是什么：不存在单独的实体，不是互联网，不是编程语言
 *                不是HTML，不是一个孤立的协议
 * 
 * 
 */


/**HTTP 相关概念
 * 1. CDN全称是“Content Delivery Network”，翻译过来就是
 *    “内容分发网络”。它应用了 HTTP 协议里的缓存和代理技术，
 *    代替源站响应客户端的请求。
 * 2. TCP 属于“传输层”，IP 属于“网际层”
 *    IP 协议是“Internet Protocol”的缩写，
 *    主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。
 * 3. TCP 协议是“Transmission Control Protocol”的缩写，
 *    意思是“传输控制协议”，它位于 IP 协议之上，
 *    基于 IP 协议提供可靠的、字节流形式的通信，
 *    是 HTTP 协议得以实现的基础。
 * 4. “可靠”是指保证数据不丢失，“字节流”是指保证数据完整，
 *     所以在 TCP 协议的两端可以如同操作文件一样访问传输的数据，
 *     就像是读写在一个密闭的管道里“流动”的字节。
 * 5. HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，为 HTTP 套了一个安全的外壳；
 * 
 */

/** 7 层 ，4 层
 * 1. TCP/IP 协议是一个“有层次的协议栈”。
 * 2. TCP/IP 当初的设计者真的是非常聪明，创造性地提出了“分层”
 *    的概念，把复杂的网络通信划分出多个层次，再给每一个层次分配
 *    不同的职责，层次内只专心做自己的事情就好，用“分而治之”的
 *    思想把一个“大麻烦”拆分成了数个“小麻烦”，从而解决了网络通信
 *    的难题
 * 3. TCP/IP 协议总共有四层，
 *    * 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，
 *    工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。
 *    * 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，
 *    所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，
 *    在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。
 *    * 第三层叫“传输层”（transport layer），
 *    这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。
 * 
 * 4. 协议栈的第四层叫“应用层”（application layer），
 *    由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了
 *    ，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。
 * 5. MAC 层的传输单位是帧（frame），IP 层的传输单位是包
 *   （packet），TCP 层的传输单位是段（segment），
 *    HTTP 的传输单位则是消息或报文（message）。
 *    但这些名词并没有什么本质的区分，可以统称为数据包。
 * 
 * 6. OSI 网络分层模型
 *    第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等；
 *    第二层：数据链路层，它基本相当于 TCP/IP 的链接层；
 *    第三层：网络层，相当于 TCP/IP 里的网际层；
 *    第四层：传输层，相当于 TCP/IP 里的传输层；
 *    第五层：会话层，维护网络中的连接状态，即保持会话和同步；
 *    第六层：表示层，把数据转换为合适、可理解的语法和语义；
 *    第七层：应用层，面向具体的应用传输数据。
 * 
 * 7. tcp/ip与osi对应关系
 *    第一层：物理层，TCP/IP 里无对应；
 *    第二层：数据链路层，对应 TCP/IP 的链接层；
 *    第三层：网络层，对应 TCP/IP 的网际层；
 *    第四层：传输层，对应 TCP/IP 的传输层；
 *    第五、六、七层：统一对应到 TCP/IP 的应用层。
 * 
 * 8. 凡是由操作系统负责处理的就是四层或四层以下，
 *    否则，凡是需要由应用程序（也就是你自己写代码）
 *    负责处理的就是七层。
 */


/**域名里有哪些门道
 * 1. DNS 的核心系统是一个三层的树状、分布式服务，基本对应域名的结构：
 *    * 根域名服务器（Root DNS Server）：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址；
 *    * 顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；
 *    * 权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。
 * 
 * 
 * 
 */


/** HTTP开发工具
 * 1. Wireshark,作为抓包工具，捕获在 TCP/IP 协议栈中传输的所有流量；
 * 2. Chrome/Firefox
 * 3. Telnet,是一个命令行工具，可用来登录主机模拟浏览器操作；
 * 4. OpenResty 作为 Web 服务器，它是一个 Nginx 的“强化包”，
 *    功能非常丰富；
 * 拷贝项目（需要Git）
 * - git clone https://github.com/chronolaw/http_study
 * - 安装OpenResty （推荐使用Homebrew）
 * - brew tap openresty/brew
 * - brew install openresty 
 * 运行项目
 * - cd http_study/www/
 * - openresty -p `pwd` -c conf/nginx.conf
 * 停止项目
 * - openresty -s quit -p `pwd` -c conf/nginx.conf
 * 
 */

/**HTTP报文
 * 请求行：
 *  1. 请求方法：是一个动词，如 GET/POST，表示对资源的操作；
 *  2. 请求目标：通常是一个 URI，标记了请求方法要操作的资源；
 *  3. 版本号：表示报文使用的 HTTP 协议版本。
 * 状态行：
 *  1. 版本号：表示报文使用的 HTTP 协议版本；
 *  2. 状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；
 *  3. 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。
 * 
 * 常用头部字段
 *  1. 通用字段：在请求头和响应头里都可以出现；
 *  2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
 *  3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
 *  4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。
 * HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。
 */


/**请求方法
 * GET：获取资源，可以理解为读取或者下载数据；
 * HEAD：获取资源的元信息；
 * POST：向资源提交数据，相当于写入或上传数据；
 * PUT：类似 POST；
 * DELETE：删除资源；
 * CONNECT：建立特殊的连接隧道；
 * OPTIONS：列出可对资源实行的方法；
 * TRACE：追踪请求 - 响应的传输路径。
 * 1. 安全：在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。
 *         按照这个定义，只有 GET 和 HEAD 方法是“安全”的，因为它们是“只读”操作，只要服务器不故意曲解请求方法的处理方式，无论 GET 和 HEAD 操作多少次，服务器上的数据都是“安全的”。
 * 2. 幂等：多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”
 * 
 * 
 * 
 */


/**
 * 
 * 浏览器永远不会把带“#fragment”的 URI 发送给服务器，服务器也永远不会用这种方式去处理资源的片段。
 * 
 * 
 */

/**状态码
 * 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
 * 2××：成功，报文已经收到并被正确处理；
 * 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
 * 4××：客户端错误，请求报文有误，服务器无法处理；
 * 5××：服务器错误，服务器在处理请求时内部发生了错误。
 * 
 * 
 */

/**HTTP有哪些特点
 * 
 * 1. 优点
 *   - HTTP 协议是一个“灵活可扩展”的传输协议
 *   - HTTP 协议是一个“可靠”的传输协议。
 *   - HTTP 协议是一个应用层的协议。
 *   - HTTP 协议使用的是请求 - 应答通信模式。
 *   - HTTP 协议是无状态的。
 *   
 * 
 * 2. 缺点
 * 
 * 
 */

/**HTTP的实体数据
 * MIME叫做“多用途互联网邮件扩展”（Multipurpose Internet Mail Extensions），简称为 MIME。
 * 1. text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，
 *    此外还有纯文本 text/plain、样式表 text/css 等。
 * 2. image：即图像文件，有 image/gif、image/jpeg、image/png 等。
 * 3. audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。
 * 4. application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 
 *    application/json，application/javascript、application/pdf 等，
 *    另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，
 *    就会是 application/octet-stream，即不透明的二进制数据。
 * 5. 但仅有 MIME type 还不够，因为 HTTP 在传输时为了节约带宽，
 *    有时候还会压缩数据，为了不要让浏览器继续“猜”，
 *    还需要有一个“Encoding type”，告诉数据是用的什么编码格式，
 *    这样对方才能正确解压缩，还原出原始的数据。
 * 6. 比起 MIME type 来说，Encoding type 就少了很多，
 *    常用的只有下面三种：
 *    - gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
 *    - deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
 *    - br：一种专门为 HTTP 优化的新压缩算法（Brotli）。
 * 7. HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，
 *    用于客户端和服务器进行“内容协商”
 * 8. Accept-Language，Accept-Charset
 * 9. Content-Type: text/html; charset=utf-8
 *    Accept-Charset: gbk, utf-8
 * 10. Accept: text/html,application/xml;q=0.9,*\/*;q=0.8
 * 
 */

/**HTTP传输大文件的方法
 * 1. 压缩
 * 2. 分块传输
 * 3. 范围请求
 * 
 * 
 * 
 */

/**HTTP的连接管理
 * TCP 建立连接要有“三次握手”，发送 3 个数据包，需要 1 个 RTT；关闭连接是“四次挥手”，4 个数据包需要 2 个 RTT。
 * 短链接：
 * 长链接：
 * Connection: keep-alive
 * Connection: close
 * “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。
 */

/**HTTP的重定向和跳转
 * 
 */


/**HTTP的Cookie机制
 * 响应头字段 Set-Cookie 和请求头字段 Cookie
 * SameSite=Strict
 * Secure
 * 
 */


/**HTTP的缓存控制
 * 缓存（Cache）是计算机领域里的一个重要概念，是优化系统性能的利器。
 * 基于“请求 - 应答”模式的特点，可以大致分为客户端缓存和服务器端缓存，
 * 
 * Cache-Control：max-age=30”
 * 这里的 max-age 是“生存时间”（又叫“新鲜度”“缓存寿命”，类似 TTL，Time-To-Live），
 * 时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），而不是客户端收到报文的时刻，也就是说包含了在链路传输过程中所有节点所停留的时间。
 * no-store
 * no-cache它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
 * must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。
 * 
 * Ctrl+F5 的“强制刷新”又是什么样的呢？它其实是发了一个“Cache-Control: no-cache”，含义和“max-age=0”基本一样，就看后台的服务器怎么理解，通常两者的效果是相同的。
 * if-Modified-Since”和“If-None-Match”这两个。需要第一次的响应报文预先提供“Last-modified”和“ETag”，然后第二次请求时就可以带上缓存里的原值，验证资源是否是最新的。
 * 强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有个“W/”标记，只要求资源在语义上没有变化，但内部可能会有部分发生了改变（例如 HTML 里的标签顺序调整，或者多了几个空格）
 * 
 */

/**HTTP的代理服务
 * 
 * 所谓的“代理服务”就是指服务本身不生产内容，
 * 而是处于中间位置转发上下游的请求和响应，
 * 具有双重身份：面向下游的用户时，表现为服务器，
 * 代表源服务器响应客户端的请求；
 * 而面向上游的源服务器时，又表现为客户端，代表客户端发送请求。
 * 
 * 
 * 代理最基本的一个功能是负载均衡。
 * 
 * 如轮询、一致性哈希等等，这些算法的目标都是尽量把外部的流量合理地分散到多台源服务器
 * 
 * 健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；
 * 安全防护：保护被代理的后端服务器，限制 IP 地址或流量，抵御网络攻击和过载；
 * 加密卸载：对外网使用 SSL/TLS 加密通信认证，而在安全的内网不加密，消除加解密成本；
 * 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应
 * 内容缓存：暂存、复用服务器响应
 * 
 * “X-Forwarded-For”的字面意思是“为谁而转发”，形式上和“Via”差不多，也是每经过一个代理节点就会在字段里追加一个信息
 * 但“Via”追加的是代理主机名（或者域名），而“X-Forwarded-For”追加的是请求方的 IP 地址。所以，在字段里最左边的 IP 地址就是客户端的地址。
 * 
 */

/**HTTP的缓存代理
 * 说它“即是客户端又是服务器”，是因为它面向源服务器时是客户端，在面向客户端时又是服务器，所以它即可以用客户端的缓存控制策略也可以用服务器端的缓存控制策略，也就是说它可以同时使用第 20 讲的各种“Cache-Control”属性。
 * 因为缓存默认是 public 的
 * 
 */

/**HTTPS是什么？SSL/TLS又是什么？
 * 1.，如果通信过程具备了四个特性，就可以认为是“安全”的，这四个特性是：机密性、完整性，身份认证和不可否认。
 * 
 * 秘密就在于 HTTPS 名字里的“S”，它把 HTTP 下层的传输协议由 TCP/IP 换成了 SSL/TLS，由“HTTP over TCP/IP”变成了“HTTP over SSL/TLS”，让 HTTP 运行在了安全的 SSL/TLS 协议上（可参考第 4 讲和第 5 讲），收发报文不再使用 Socket API，而是调用专门的安全接口。
 * 2. SSL 即安全套接层（Secure Sockets Layer），在 OSI 模型中处于第 5 层（会话层），由网景公司于 1994 年发明，有 v2 和 v3 两个版本，而 v1 因为有严重的缺陷从未公开过。
 * 3. SSL 发展到 v3 时已经证明了它自身是一个非常好的安全通信协议，于是互联网工程组 IETF 在 1999 年把它改名为 TLS（传输层安全，Transport Layer Security），正式标准化，版本号从 1.0 重新算起，所以 TLS1.0 实际上就是 SSLv3.1。
 * 4. 浏览器和服务器在使用 TLS 建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”（cipher suite，也叫加密套件）。
 * 
 * 
 * 
 */

/**对称加密与非对称加密
 * 
 * 
 */

/**数字签名与证书
 * 摘要算法(SHA-2)
 * 哈希消息认证码（HMAC)
 * 
 * 
 */


/**HTTPS
 * 在 HTTP 协议里，建立连接后，浏览器会立即发送请求报文。
 * 但现在是 HTTPS 协议，它需要再用另外一个“握手”过程，
 * 在 TCP 上建立安全连接，之后才是收发 HTTP 报文。
 * HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接；
 * 
 */

/**
 * HTTP/2特性概览
 * “HPACK”算法是专门为压缩 HTTP 头部定制的算法，
 * 为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——“伪头字段”（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。
 * 
 * 
 * 
 * 
 * 
 */


/**HTTP3
 * QUIC 的基本数据传输单位是包（packet）和帧（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。
 * 
 * 你应该知道，影响网络速度的两个关键因素是“带宽”和“延迟”，HTTP/2 的头部压缩、多路复用、流优先级、服务器推送等手段其实都是针对这两个要点。
 * 
 * 
 * 
 */